# opt$sort_str       = "bitscore,d"
# opt$min_pident     = 98
# opt$min_coverage   = 98
# opt$fasta_header   = "sallseqid"
# opt$fasta2extract  = "MLST/SAH1503.nucl.merge.fa"
# opt$num_hits       = "1"
if(!is.null(opt$store_opts)) {
save(opt, file = opt$store_opts)
}
# Read blast results:
blast <- read.delim(opt$blast,
he = F,
stringsAsFactors = F)
# print(opt$merge_metadata)
my.colnames = strsplit(opt$names,
split = " ") %>% unlist
# print(opt$merge_blast)
#
# Check matche between names and blast table:
if(length(colnames(blast)) != length(my.colnames)){
opt_parser %>% print_help
stop(cat("length of names and blast file don't match!"))
}
# Set column names
names(blast) = strsplit(opt$names,
split = " ") %>% unlist
# The following section merges in the metadata. Do only if metadata is passed!
if(!is.null(opt$merge_metadata)) {
# Make sure the column names used for merging with metadata exists:
stopifnot(opt$merge_blast %in% colnames(blast) )
# Read gene metadata:
metadata = read.delim(file             = opt$dbtable,
header           = T,
comment.char     = "#",
quote            = "",
stringsAsFactors = F)
# Test passes merge field exists in metadata file:
if(!(opt$merge_metadata %in% names(metadata))){
opt_parser %>% print_help
stop(sprintf("--merge_metadata ('%s') does not exist in metadata columns! (%s)\n",
opt$merge_metadata,
paste(names(metadata),collapse = ", ")))
}
# Merge metadata into main blast results:
blast <- merge(blast,
metadata,
by.y = opt$merge_metadata,
by.x = opt$merge_blast)
}
# Check that opt$group_dif_name exists in blast df:
if(!(opt$group_dif_name %in% names(blast))){
opt_parser %>% print_help
stop(sprintf("--group_dif_name ('%s') does not exist in blast or metadata columns! (%s)\n",
opt$group_dif_name,
paste(names(blast),collapse = ", ")))
}
# Calculating coverage as length of hit (hsp) / total length
# This is what Eliad used (possibly inherited from Nir Gilad)
# See /fastspace/bioinfo_projects/SPICE/01.Legionella/12.Pathogenicity_VFDB_Acinetobacter/02e.Pipe.VFDB_updated/virulanceAllGenes.pl
# Line 96
# Not exacly the same - he parsed a full blast output and here I'm parsing a tabular output...
if (all("qstart" %in% names(blast),
"qend"   %in% names(blast),
"qlen"   %in% names(blast))) {
blast$align_len = abs(blast$qstart - blast$qend) + 1
blast$coverage  = blast$align_len / blast$qlen * 100
} else {
if(any(opt$min_coverage > 0, opt$min_align_len > 0)) {
opt_parser %>% print_help
stop(cat("Fields in blast report don't enable filtering by coverage and protein length
The BLAST report must have 'qstart', 'qend' and 'qlen' fields."))
}
}
# If no columns2keep was passed, set to all columns,
# otherwise, check that all columns2keep are included in the blast column names
if (is.null(opt$columns2keep)){
opt$columns2keep <- names(blast)
sprintf("No --columns2keep passed. Outputting all columns\n") %>% cat
} else {
opt$columns2keep <- strsplit(x     = opt$columns2keep,
split = "\\s+",
perl  = T) %>% unlist
if(!all(opt$columns2keep %in% names(blast))) {
stop(sprintf("--columns2keep contains unrecognised columns... (%s).\n",
paste(setdiff(opt$columns2keep,names(blast)),
collapse = ", ")))
}
}
# Convert sort_str from input string into valid string for sorting below:
opt$sort_str <-
opt$sort_str                           %>%
strsplit(.,",")                    %>%     # Split by comma
unlist                             %>%     # Convert to character vector
matrix(.,
ncol=2,
byrow = T)                  %>%     # Convert to 2-column matrix
data.frame(.,stringsAsFactors = F) %>%     # Convert to data.frame
setNames(.,c("column","direction"))        # Set names of df
# Checking that second column is only 'd' or 'i'
if(length(setdiff(opt$sort_str$direction,c("d","i"))) > 0) {
opt_parser %>% print_help
stop(cat("--sort_str is badly formatted. Make sure every field has a direction tag ('d' or 'i') following it\n"))
}
# Create new column with '-' for decreasing order:
opt$sort_str$direction_tag <- ifelse(test = opt$sort_str$direction=="d","-","")
# Storing column names:
sort_cols <- opt$sort_str$column
# Paste to create string:
opt$sort_str <- paste(paste(opt$sort_str$direction_tag,
opt$sort_str$column,
sep=""),
collapse = ",")
if(!all(sort_cols %in% names(blast))) {
stop(sprintf("--sort_str contains unrecognised columns... (%s).\n",
paste(setdiff(sort_cols,
names(blast)),
collapse = ", ")))
}
# ------------------------------------
# Retrieve best ortholog (based on bitscore) for each VFG query:
# Helper function. Sorts a sub-data.frame by bitscore, then by evalue and returns the first row.
get_best_hit <- function(x) {
# Step 1 - filter out lines that don't match the requierments (give in opts)
if(any(exists("coverage", where=x),
exists("align_len", where=x))) {
x <- subset(x,subset = bitscore  >= opt$min_bitscore  &
evalue    <= opt$max_evalue    &
coverage  >= opt$min_coverage  &
align_len >= opt$min_align_len &
pident    >= opt$min_pident)
} else {
x <- subset(x,subset = bitscore  >= opt$min_bitscore  &
evalue    <= opt$max_evalue    &
pident    >= opt$min_pident)
}
# If all lines are required or more lines than exist in the result group, set num hits to number of rows.
if((opt$num_hits == "all") | (as.numeric(opt$num_hits) > dim(x)[1])) {
opt$num_hits <- dim(x)[1]
}
# Step 2 - take 'opt$num_hits' results of those that pass filtration
retval <- eval(parse(text = sprintf("x[with(x,order(%s)),][1:as.numeric(opt$num_hits),]",
opt$sort_str)))
# If all results for a gene were filtered out, retval will be all NAs
# return NULL to remove from final filtered blast table
if(all(is.na(retval))) return(NULL)
return(retval)
}
if(exists("single", where = opt)) {
# Use entire BLAST report as result for one gene. Return best line in entire table:
blast <- get_best_hit(blast)
} else {
# Use
cat("Running ddply. Takes a while...\n")
# Cuts the 'blast' df into pieces by 'name', and runs get_best_hit on each slice.
# The lines returned by get_best_hit are concatenated into a new df, 'blast'...
blast_df_names <- names(blast)
blast <- ddply(.data      = blast,
.variables = as.quoted(opt$group_dif_name),
.fun       = get_best_hit)
# If there are no results, set blast to an empty df with the same col names as before:
if(dim(blast)[1]==0) {
blast <- data.frame(matrix(vector(), 0, length(blast_df_names),
dimnames=list(c(), blast_df_names)),
stringsAsFactors=F)
}
}
# Print output to file (if there are results at all):
write.table(blast[,opt$columns2keep],
file      = opt$output,
quote     = F,
row.names = F,
sep       = "\t")
cat("Done...\n")
cat(sprintf("See output file at: %s\n", opt$output))
blast
library(Biostrings)
if(!file.exists(opt$fasta2extract)) {
stop(sprintf("FASTA file %s does not exist!\n",opt$fasta2extract))
}
# Create fasta file index
fastaindex <- fasta.index(filepath =  opt$fasta2extract)
library(Biostrings)
# Check fasta file exists:
if(!file.exists(opt$fasta2extract)) {
stop(sprintf("FASTA file %s does not exist!\n",opt$fasta2extract))
}
opt$fasta2extract
opt$fasta2extract  = "MLST/SAH1503.nucl.merge.fa"
if(!file.exists(opt$fasta2extract)) {
stop(sprintf("FASTA file %s does not exist!\n",opt$fasta2extract))
}
# Create fasta file index
fastaindex <- fasta.index(filepath =  opt$fasta2extract)
fastaindex
dim(blast)[1]
for(i in 1:dim(blast)[1]) {
# If it is in reverse: (see documentation below for non-reverse)
newseq <- readBStringSet(fastaindex[grep(pattern = blast[i,opt$fasta_header],
x       = fastaindex$desc),])
if(blast[i,"sstart"] > blast[i,"send"]) {
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"send"],
end = blast[i,"sstart"])    %>%
DNAStringSet                   %>%
reverseComplement
names(newseq) <- paste(names(newseq),blast[i,"send"],blast[i,"sstart"],"revcomp",
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
} else {
# Get the full sequence from the fasta file
# get subsequence of it based on blast table (sstart and send)
# newseq <- fastaindex[which(fastaindex$desc==blast[i,opt$fasta_header])]
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"sstart"],
end = blast[i,"send"])
names(newseq) <- paste(names(newseq),blast[i,"sstart"],blast[i,"send"],
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
# Add coordinates to the seq name:
# Write the sequence to file
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
}
}
opt$output
opt$output         = paste(opt$blast,"parse.out",sep=".")
i
for(i in 1:dim(blast)[1]) {
# If it is in reverse: (see documentation below for non-reverse)
newseq <- readBStringSet(fastaindex[grep(pattern = blast[i,opt$fasta_header],
x       = fastaindex$desc),])
if(blast[i,"sstart"] > blast[i,"send"]) {
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"send"],
end = blast[i,"sstart"])    %>%
DNAStringSet                   %>%
reverseComplement
names(newseq) <- paste(names(newseq),blast[i,"send"],blast[i,"sstart"],"revcomp",
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
} else {
# Get the full sequence from the fasta file
# get subsequence of it based on blast table (sstart and send)
# newseq <- fastaindex[which(fastaindex$desc==blast[i,opt$fasta_header])]
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"sstart"],
end = blast[i,"send"])
names(newseq) <- paste(names(newseq),blast[i,"sstart"],blast[i,"send"],
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
# Add coordinates to the seq name:
# Write the sequence to file
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
}
}
opt$output
opt$dbtable        = "MLST/MLST_scheme.tab"
opt$blast          =  "MLST/SAH1503/SAH1503.blast.out"
opt$output         = paste(opt$blast,"parse.out",sep=".")
opt$merge_blast    = "qseqid"
opt$merge_metadata = "Allele"
opt$group_dif_name = "Gene"
opt$names = "qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe"
opt$columns2keep = "qseqid sallseqid qlen"
opt$sort_str       = "bitscore,d"
opt$min_pident     = 98
opt$min_coverage   = 98
opt$fasta_header   = "sallseqid"
opt$fasta2extract  = "MLST/SAH1503.nucl.merge.fa"
opt$num_hits       = "1"
for(i in 1:dim(blast)[1]) {
# If it is in reverse: (see documentation below for non-reverse)
newseq <- readBStringSet(fastaindex[grep(pattern = blast[i,opt$fasta_header],
x       = fastaindex$desc),])
if(blast[i,"sstart"] > blast[i,"send"]) {
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"send"],
end = blast[i,"sstart"])    %>%
DNAStringSet                   %>%
reverseComplement
names(newseq) <- paste(names(newseq),blast[i,"send"],blast[i,"sstart"],"revcomp",
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
} else {
# Get the full sequence from the fasta file
# get subsequence of it based on blast table (sstart and send)
# newseq <- fastaindex[which(fastaindex$desc==blast[i,opt$fasta_header])]
if(!exists("fasta_allsubject",opt)) {
newseq <- subseq(newseq,
start = blast[i,"sstart"],
end = blast[i,"send"])
names(newseq) <- paste(names(newseq),blast[i,"sstart"],blast[i,"send"],
sep="_")
if(exists("dbtable",opt)) {
names(newseq) <- paste(names(newseq), blast[i,opt$merge_blast], sep="|")
}
}
# Add coordinates to the seq name:
# Write the sequence to file
writeXStringSet(newseq,
filepath = sprintf("%s.fasta",opt$output),
append = TRUE,
compress=FALSE,
format="fasta")
}
}
paste("Rscript",
"parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
"--fasta_header",       "sallseqid"
) %>% system
paste("Rscript",
"parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
"--fasta_allsubject",
"--fasta_header",       "sallseqid"
) %>% system
paste("Rscript",
"parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
"--fasta_allsubject",
"--fasta_header",       "sallseqid"
) %>% system
paste("Rscript",
"compare_blast_parsed_reports.R",
"--blastind",    "Amir_Sagi/parse_perSample_CLC/parsed_BLAST_files_index.txt",
"--variable",  "bitscore",
"--name",    "qseqid",
"--full_txt_output"
) %>% system
paste("Rscript",
"compare_blast_parsed_reports.R",
"--blastind",    "Amir_Sagi/parse_perSample_CLC/parsed_BLAST_files_index.txt",
"--variable",  "bitscore",
"--name",    "qseqid",
"--full_txt_output"
) %>% system
paste("Rscript","parse_blast_general.R","-h") %>% system
paste("Rscript","src/parse_blast_general.R","-h") %>% system
paste("Rscript","src/parse_blast_general.R","-h") %>% system
paste("Rscript","src/parse_blast_general.R","-h") %>% system
paste("Rscript","src/parse_blast_general.R","-h") %>% system
paste("Rscript",
"parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
#     "--fasta_allsubject",
"--fasta_header",       "sallseqid"
) %>% system
paste("Rscript",
"./src/parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
#     "--fasta_allsubject",
"--fasta_header",       "sallseqid"
) %>% system
) %>% paste
paste("Rscript",
"./src/parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
#     "--fasta_allsubject",
"--fasta_header",       "sallseqid"
# ) %>% system
) %>% paste
(!("Biostrings" %in% installed.packages()))
"Biostrings" %in% installed.packages()
?break()
?Control
source("temp.R")
source("temp.R")
paste("Rscript",
"./src/parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
"--fasta_allsubject",
"--fasta_header",       "sallseqid"
# ) %>% system
) %>% paste
paste("Rscript",
"./src/parse_blast_general.R",
"--blast",           "MLST/SAH1503/SAH1503.blast.out",
"--dbtable",         "MLST/MLST_scheme.tab",
"--names",          "\"qseqid sallseqid qlen slen qstart qend sstart send length evalue bitscore score pident qframe\"",
"--merge_blast",    "qseqid",
"--merge_metadata", "Allele",
"--group_dif_name", "Gene",
"--min_pident",     "98",
"--min_coverage",   "98",
"--max_evalue",     "1e-7",
"--num_hits",       "1",
"--sort_str",       "bitscore,d",
"--fasta2extract",       "MLST/SAH1503.nucl.merge.fa",
"--fasta_allsubject",
"--fasta_header",       "sallseqid"
) %>% system
paste("Rscript","src/parse_blast.R","-h") %>% system
