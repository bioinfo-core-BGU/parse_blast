#       "--dbtable",  "VFG_SN_to_info_v6_with_vfDesc.tsv",
#       "--names",    "\"qseqid sallseqid qlen\"") %>% system
# paste("Rscript","compare_blast_parsed_reports.R","-h") %>% system
args    = commandArgs(trailingOnly = F)
filepos = args %>% grep("--file=",x = .)
curfile = sub(pattern     = "--file=",
replacement = "",
x           = args[filepos]) %>% file_path_as_absolute
print(curfile)
args = commandArgs(trailingOnly=TRUE)
option_list = list(
make_option(c("-b", "--blastind"),      type="character", default=NULL,
help="Path to index file of blast results",   metavar="character"),
make_option(c("-v", "--variable"),      type="character", default="bitscore",
help="Variable to keep in table (bitscore).", metavar="character"),
make_option(c("-n", "--name"),      type="character", default="name",
help="Column to use as gene names, i.e. row identifier.", metavar="character"),
make_option(c("-o", "--output"),        type="character", default=NULL,
help="Path to output file",                   metavar="character"),
make_option(c("-u", "--full_txt_output"), type="logical", action = "store_true",
help="Path to output file", metavar="character")
);
opt_parser = optparse::OptionParser(usage       = "
This script takes an index file of form 'ID\tfilename' where filename is a BLAST tabular output WITH headers.
The files are read and merged and then reshaped such that columns are sample IDs, rows are genes (--name) and the values of the tables are those in column --variable.
usage: %prog [options]",
option_list = option_list,
epilogue    = "NOTE: The BLAST tables must have a header line and --variable and --name must be column titles.\n\nAuthor: Menachem Sklarz");
opt = optparse::parse_args(opt_parser);
if (is.null(opt$blastind)){
paste("Rscript",curfile,"-h") %>% system
stop(cat("No --blastind was passed!\n"))
}
if (is.null(opt$output)){
paste("Rscript",curfile,"-h") %>% system
stop(cat("No --output was passed!\n"))
}
# Libraries are loaded here so that the opt parsing is done before failure due to uninstalled packages.
library(magrittr)
library(plyr )
library(reshape2 )
# For debugging:
opt$output = "Amir_Sagi/parse_perSample_CLC/output"
opt$blastind = "Amir_Sagi/parse_perSample_CLC/parsed_BLAST_files_index.txt"
# User defined parameters (future):
#   blast : blast_report
#   blast_names : names of blast columns
opt
file_index = read.delim(opt$blastind,
he=F,
stringsAsFactors = F,
comment.char = "#")
file_index
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
file_index
blast_df
file_index
file_index[15,]
file_index[15,] -> x
x
x[2]
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
blast_df
library(plyr)
file_index<- file_index[1:5,]
file_index
library(plyr)
t1 <- alply(.data = file_index,
.margins = 1,
.fun =  function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
t1
t1 <- alply(.data = file_index,
.margins = 1,
.fun =  function(x) {
print(x)
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
blast_table
c<- file_index[2,]
x<- file_index[2,]
print(x)
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
blast_table
x[2]
read.delim(x[2])
read.delim(x[1,2])
read.delim(x[2,drop=TRUE])
blast_table <- try_default(expr = read.delim(x[1,2],
he = T),
default = NULL)
blast_table
blast_table <- try_default(expr = read.delim(x[1,2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[1,2]))
return(NULL)
}
blast_table
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
blast_table$sample_name <- x[1,1];
blast_table
t1 <- alply(.data = file_index,
.margins = 1,
.fun =  function(x) {
print(x)
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[1,2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[1,2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1,1];
return(blast_table)
})
t1
?apply
t1 <- alply(.data = file_index,
.margins = 1,
.expand = F,
.fun =  function(x) {
print(x)
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[1,2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[1,2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1,1];
return(blast_table)
})
t1
blast_table
x[1]
x[1,1]
list(blast_table)
list(blast_table) %>% setNames(.,x[1,1])
list(NULL) %>% setNames(.,x[1,1])
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(list(NULL) %>% setNames(.,x[1,1]))
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(list(blast_table) %>% setNames(.,x[1,1]))
})
blast_df
file_index
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(list(NULL) %>% setNames(.,x[1]))
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(list(blast_table) %>% setNames(.,x[1]))
})
blast_df
str(blast_df)
blast_df%>%unlist
t1 <- alply(.data = file_index,
.margins = 1,
.expand = F,
.fun =  function(x) {
print(x)
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[1,2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[1,2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1,1];
return(blast_table)
})
t1
dim(t1)
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
blast_df
blast_df  <- do.call("rbind", blast_df)
blast_df
setdiff(file_index$V1,blast_df$sample_name)
file_index = read.delim(opt$blastind,
he=F,
stringsAsFactors = F,
comment.char = "#")
# For each file in table:
#   Create list of tables, one for each sample:
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
setdiff(file_index$V1,blast_df$sample_name)
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
#   concatenate by row (rbind) = merge all tables into one long table
# blast_df  <- do.call("rbind", blast_df)
setdiff(file_index$V1,blast_df$sample_name)
blast_df$sample_name
blast_df
blast_df  <- do.call("rbind", blast_df)
setdiff(file_index$V1,blast_df$sample_name)
empty_samples <- setdiff(file_index$V1,
blast_df$sample_name)
if(empty_samples) print("yes")
empty_samples
file_index
file_index<- file_index[1:5,]
#   Create list of tables, one for each sample:
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
#   concatenate by row (rbind) = merge all tables into one long table
blast_df  <- do.call("rbind", blast_df)
empty_samples <- setdiff(file_index$V1,
blast_df$sample_name)
empty_samples
empty_samples%>%length
empty_samples <- "fff"
empty_samples%>%length
file_index = read.delim(opt$blastind,
he=F,
stringsAsFactors = F,
comment.char = "#")
# For each file in table:
#   Create list of tables, one for each sample:
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
#   concatenate by row (rbind) = merge all tables into one long table
blast_df  <- do.call("rbind", blast_df)
empty_samples <- setdiff(file_index$V1,
blast_df$sample_name)
empty_samples
length(empty_samples) > 0
blast_df[dim(blast_df)[1]+length(empty_samples),
dim(blast_df)[2]] <- NA
blast_df
dim(blast_df)[1]
dim(blast_df)[1]-length(empty_samples)+1
blast_df$sample_name[dim(blast_df)[1]-length(empty_samples)+1] <- empty_samples
blast_df
file_index
# For each file in table:
#   Create list of tables, one for each sample:
blast_df <- apply(  X      = file_index,
MARGIN = 1,
FUN    = function(x) {
# Reading parsed results file:
blast_table <- try_default(expr = read.delim(x[2],
he = T),
default = NULL)
# No file read:
if(blast_table %>% is.null) {
cat(sprintf("Could not read file %s\n",x[2]))
return(NULL)
}
# Solving issue of empty files:
if(dim(blast_table)[1]==0) blast_table[1,1] <- NA
# Setting sample name column:
blast_table$sample_name <- x[1];
return(blast_table)
})
#   concatenate by row (rbind) = merge all tables into one long table
blast_df  <- do.call("rbind", blast_df)
empty_samples <- setdiff(file_index$V1,
blast_df$sample_name)
empty_samples
length(empty_samples) > 0
blast_df[dim(blast_df)[1]+length(empty_samples),
dim(blast_df)[2]] <- NA
blast_df
blast_df$sample_name[dim(blast_df)[1]-length(empty_samples)+1] <- empty_samples
blast_df
empty_samples
blast_df$sample_name[(dim(blast_df)[1]-length(empty_samples)+1):(dim(blast_df)[1])]
blast_df$sample_name[(dim(blast_df)[1]-length(empty_samples)+1):(dim(blast_df)[1])] <- empty_samples
blast_df
if(!all(c(opt$name, opt$variable) %in% names(blast_df))) {
stop(sprintf("--name (%s) or --variable (%s) do not exist in table header (%s)",
opt$name,
opt$variable,
paste(names(blast_df),
collapse = " ")
)
)
}
opt
opt$name
opt$name<-"qseqid"
if(!all(c(opt$name, opt$variable) %in% names(blast_df))) {
stop(sprintf("--name (%s) or --variable (%s) do not exist in table header (%s)",
opt$name,
opt$variable,
paste(names(blast_df),
collapse = " ")
)
)
}
blast_tbl <- dcast(data       = blast_df,
formula   = sprintf("%s ~ sample_name",opt$name),
value.var = opt$variable)
cat("Producing outputs:\n------------------\n")
cat(sprintf("Writing summary table to: %s\n", opt$output))
opt$output
write.table(x         = blast_tbl,
file      = opt$output,
append    = F,
quote     = F,
sep       = "\t",
row.names = F)
blast_tbl
blast_tbl$qseqid%>%is.na()
blast_tbl[opt$name]%>%is.na()
blast_tbl[opt$name]%>%is.na()%>%not
blast_tbl[not(is.na(blast_tbl[opt$name])),]
blast_tbl <- blast_tbl[not(is.na(blast_tbl[opt$name])),]
write.table(x         = blast_tbl,
file      = opt$output,
append    = F,
quote     = F,
sep       = "\t",
row.names = F)
opt
opt$full_txt_output <- TRUE
exists(x = "full_txt_output", where = opt)
if(exists(x = "full_txt_output", where = opt)) {
full_name <- paste(dirname(file_path_as_absolute(opt$output)),
.Platform$file.sep,
"flat_file_table.txt",
sep="")
cat(sprintf("Writing full flat table to: %s\n", full_name))
write.table(x         = blast_df,
file      = full_name,
append    = F,
quote     = F,
sep       = "\t",
row.names = F)
} else {
full_name <- paste(dirname(file_path_as_absolute(opt$output)),
.Platform$file.sep,
"flat_file_table.txt",
sep="")
cat(sprintf("Writing full flat table to: %s\n", full_name))
save(blast_df,
file = full_name
)
}
